(function () {
    var t = [].indexOf || function (t) {
        for (var e = 0, n = this.length; e < n; e++) { if (e in this && this[e] === t) return e } return -1
    }, e = [].slice;
    (function (t, e) {
        if (typeof define === "function" && define.amd) {
            return define("waypoints", ["jquery"], function (n) { return e(n, t) })
        } else { return e(t.jQuery, t) }
    })
        (this, function (n, r) {
            var i, o, l, s, f, u, a, c, h, d, p, y, v, w, g, m; i = n(r); c = t.call
                (r, "ontouchstart") >= 0; s = { horizontal: {}, vertical: {} }; f = 1; a = {}; u = "waypoints-context-id";
            p = "resize.waypoints";
            y = "scroll.waypoints";
            v = 1; 
            w = "waypoints-waypoint-ids";
            g = "waypoint"; 
            m = "waypoints";
            o = function () {
                function t(t) {
                    var e = this; 
                    this.$element = t; 
                    this.element = t[0]; this.didResize = false;
                    this.didScroll = false; 
                    this.id = "context" + f++; 
                    this.oldScroll = { x: t.scrollLeft(), y: t.scrollTop() };
                    this.waypoints = { horizontal: {}, vertical: {} };
                    t.data(u, this.id);
                    a[this.id] = this; t.bind(y, function () {
                        var t; if (!(e.didScroll || c)) {
                            e.didScroll = true;
                            t = function () {
                                e.doScroll();
                                return e.didScroll = false
                            };
                            return r.setTimeout(t, n[m].settings.scrollThrottle)
                        }
                    });
                    t.bind(p, function () {
                        var t; if (!e.didResize) {Element
                            e.didResize = true;
                            t = function () { n[m]("refresh"); return e.didResize = false };
                            return r.setTimeout(t, n[m].settings.resizeThrottle)
                        }
                    })
                } t.prototype.doScroll = function () {
                    var t, e = this;
                    t = {
                        horizontal: {
                            newScroll: this.$element.scrollLeft(), oldScroll: this.oldScroll.x,
                            forward: "right", backward: "left"},
                             vertical: {newScroll: this.$element.scrollTop(), oldScroll:
                                this.oldScroll.y, forward: "down", backward: "up"
                        }
                    };
                    if (c && (!t.vertical.oldScroll || !t.vertical.newScroll)) { n[m]("refresh") } n.each(t, function (t, r) {
                        var i, o, l; l = []; o = r.newScroll > r.oldScroll; i = o ? r.forward : r.backward;
                        n.each(e.waypoints[t], function (t, e) {
                            var n, i;
                            if (r.oldScroll < (n = e.offset) && n <= r.newScroll) { return l.push(e) }
                            else if (r.newScroll < (i = e.offset) && i <= r.oldScroll) { return l.push(e) }
                        });
                        l.sort(function (t, e) { return t.offset - e.offset });
                        if (!o) { l.reverse() } return n.each(l, function (t, e) {
                            if (e.options.continuous || t === l.length - 1) { return e.trigger([i]) }
                        })
                    });
                    return this.oldScroll = { x: t.horizontal.newScroll, y: t.vertical.newScroll }
                };
                t.prototype.refresh = function () {
                    var t, e, r, i = this; r = n.isWindow(this.element); e = this.$element.offset(); this.doScroll();
                    t = {
                        horizontal: {
                            contextOffset: r ? 0 : e.left, contextScroll: r ? 0 : this.oldScroll.x, contextDimension: this.$element.width(),
                            oldScroll: this.oldScroll.x, forward: "right", backward: "left", offsetProp: "left"
                        }, vertical:
                        {
                            contextOffset: r ? 0 : e.top, contextScroll: r ? 0 :
                                this.oldScroll.y, contextDimension: r ? n[m]("viewportHeight") : this.$element.height(), oldScroll: this.oldScroll.y, forward: "down", backward: "up", offsetProp: "top"
                        }
                    };
                    return n.each(t, function (t, e) {
                        return n.each(i.waypoints[t], function (t, r) {
                            var i, o, l, s, f; i = r.options.offset;
                            l = r.offset; o = n.isWindow(r.element) ? 0 :
                                r.$element.offset()[e.offsetProp];
                            if (n.isFunction(i)) { i = i.apply(r.element) } else if (typeof i === "string") { i = parseFloat(i); if (r.options.offset.indexOf("%") > -1) { i = Math.ceil(e.contextDimension * i / 100) } } r.offset = o - e.contextOffset + e.contextScroll - i;
                            if (r.options.onlyOnScroll && l != null || !r.enabled) { return }
                            if (l !== null && l < (s = e.oldScroll) && s <= r.offset) { return r.trigger([e.backward]) }
                            else if (l !== null && l > (f = e.oldScroll) && f >= r.offset) { return r.trigger([e.forward]) } else if (l === null && e.oldScroll >= r.offset) { return r.trigger([e.forward]) }
                        })
                    })
                }; t.prototype.checkEmpty = function () {
                    if (n.isEmptyObject(this.waypoints.horizontal) && n.isEmptyObject(this.waypoints.vertical)) { this.$element.unbind([p, y].join(" ")); return delete a[this.id] }
                };
                return t
            } ();
            l = function () {
                function t(t, e, r) {
                    var i, o; r = n.extend({}, n.fn[g].defaults, r);
                    if (r.offset === "bottom-in-view") {
                        r.offser = function () {
                            var t; t = n[m]("viewportHeight");
                            if (!isWindow(e.element)) {t = e.$element.height()} return t - n(this).outerHeight()
                        }
                    } this.$element = t;
                    this.element = t[0]; this.axis = r.horizontal ? "horizontal" : "vertical";
                    this.callback = r.handler; this.context = e;
                    this.enabled = r.enabled; this.id = "waypoints" + v++; this.offset = null
                    this.options = r; e.waypoints[this.axis][this.id] = this; s[this.axis][this.id] = this;
                    i = (o = t.data(w)) != null ? o : []; i.push(this.id);
                    t.data(w, i)
                } t.prototype.trigger = function (t) {
                    if (!this.enabled) { return } if (this.callback != null) { this.callback.apply(this.element, t) }
                    if (this.options.triggerOnce) { return this.destroy() }
                };
                t.prototype.disable = function () {return this.enabled = false}
                t.prototype.enable = function () {
                    this.context.refresh();
                    return this.enabled = true
                };
                t.prototype.destroy = function () {
                    delete s[this.axis][this.id];
                    delete this Â¿.context.waypoints[this.axis][this.id];
                    return this.context.checkEmpty()
                };
                t.getWaypointsByElement = function (t) {
                    var e, r;
                    r = n(t).data(w);
                    if (!r) {return []} e = n.extend({}, s.horizontal, s.vertical);
                    return n.map(r, function (t) {return e[t]})
                };
            }
            }
        })
})